### 主题：多线程基础

### 简介
   + 学习黄文海-《Java多线程编程实战指南-核心篇》，多线程技术要点知识整理总结及体会

### 章节简介
   1. 走近Java世界中的线程
        - 简介：
        主要介绍**线程**及**多线程编程**这两个基本概念，以及**Java平台的线程API**，并通过
        一个实战案例使读者**对多线程编程有个初步和感性的认识**。
   2. 多线程编程的目标与挑战
        - 简介：
        主要介绍**多线程编程所要实现的目标**及其**面临的挑战**。明确多线程编程的目标有助
        于我们在实践中做到有的放矢，掌握多线程编程所面临的挑战使得我们在学习本书后续
        内容时能够做到有的放矢，掌握多线程编程所面临的挑战使得我们在学习本书后续内容
        时能够做到知其然而且知其所以然。
   3. Java线程同步机制
        - 简介：
        主要介绍Java平台所提供的能够用于应对多线程编程所面临的部分挑战的一些**关键字
        和标准库类(API)**，以及这些**关键字和API的性能开销、适用场景及注意事项**。
   4. 牛刀小试：玩转线程
        - 简介：
        通过实战案例介绍具体如何玩转线程以实现多线程编程的目标，并通过这些实战案例展开
        **介绍多线程编程实践中的一些实际问题及应对措施**。
   5. 线程间协作
        - 简介：
        主要介绍**线程与线程之间通过哪些常见的协作形式**来实现多线程编程的目标以及**Java所
        支持的相应标准类**。
   6. 保障线程安全的设计技术
        - 简介：
        主要从**软件设计角度**出发介绍**应对多线程编程所面临的一些挑战的常见技术**。
   7. 线程的活性故障
        - 简介
        主要介绍多线程程序可能产生的一些常见的**具有隐蔽性的故障**以及**相应的规避措施**。
   8. 线程管理
        - 简介：
        主要介绍在多线程编程中如何**更加有效和有效率地使用线程**。
   9. Java异步编程
        - 简介：
        主要从**计算模型的角度**出发介绍多线程编程中如何**利用线程来提高软件的吞吐率和响应性**。
   10. Java多线程程序的调试与测试
        - 简介：
        主要介绍Java平台中多线程程序的**调试技巧与测试手段**。
   11. 多线程编程的硬件基础与Java内存模型
        - 简介：
        主要介绍**多线程编程的硬件基础**以及Java平台为屏蔽不同硬件平台的差异而进行的抽象（**Java内存模型**）。
   12. Java多线程程序的性能调校
        - 简介：
        结合实战案例介绍与Java平台中的多线程程序紧密相关的**常用性能优化方法与技术**。
        
### 章节要点提炼
   1. 走近Java世界中的线程
        - 核心概要：1)线程和多线程编程两个概念2)Java线程API
        - 1.1 **进程、线程与任务**
        - 1.2 **多线程编程简介**
        - 1.3 **Java线程API简介**
        - 1.4 无处不在的线程
        - 1.5 线程的层次关系
        - 1.6 **线程的生命周期状态**
        - 1.7 线程的监视
        - 1.8 多线程编程简单运用案例
        - 1.9 **多线程编程的优势和风险**
        ---
        - 1.1 进程、线程与任务
            - **进程**：是程序的运行实例。运行一个Java程序的实质是启动一个Java虚拟机进程。
                - 进程是程序向操作系统申请资源（如内存空间和文件句柄）的基本单位。
                - 一个进程可以包含多个线程。
            - **线程**：是进程中可以独立执行的最小单位。
                - 同一个进程中的所有线程共享该进程中的资源。
            - **任务**：线程所要完成的计算。
                - 任务代表线程所要完成的工作。
        - 1.2 多线程编程简介
            - 多线程编程：以线程为基本抽象单位的一种编程范式。
                - 在Java平台一个线程就是一个对象。
        - 1.3 Java线程API
            - Java标准库类java.lang.Thread就是Java平台对线程的实现。
                - Thread类或其子类的一个实例就是一个线程。
            - Java平台中创建一个线程就是创建一个Thread类（或其子类）的实例。
            - 每个线程都有其要执行的任务。线程的任务逻辑在run方法中实现。
                - run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用。
            - 启动一个线程实质上是请求Java虚拟机运行相应的线程，而这个线程具体何时运行由**线程调度器**决定的。
            - 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。
            - Thread类的两个常用构造器：Thread和Thread(Runnable targe).
                - Java语言中创建线程的两种方式:1)定义Thread子类，覆盖子类的run方法，实现线程任务处理逻辑；2)创建
                一个java.lang.Runnable接口的实例，在run方法中实现任务处理逻辑，调用Thread(Runnable targe)构建器
                创建Thread类的实例。
            - 线程的run方法执行结束，相应的线程的运行也就结束了。包括正常结束及代码抛出异常而导致中止。运行结束的线程
                所占用的资源会如同其它Java对象一样被Java虚拟机垃圾回收。
            - 线程属于"一次性用品",不能通过重新调用一个已经运行结束的线程的start方法来使用重新运行。start方法只能够被
            调用一次，多次调用start方法会导致抛出IllegalThreadStateException异常。
            - 在Java平台中，一个线程就是一个对象。创建一个线程与创建其他类型的Java对象所不同的是：1)Java虚拟机会为每个
            线程分配调用栈(Call Stack)所需的内存空间。2)Java平台每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。
                - 调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码的调用。
            - **执行线程**：Java平台中的任意一段代码总是由确定的线程负责执行的。这个线程就相应地被称为这段代码的执行线程。
                - 同一段代码可以被多个线程执行。
            - **当前线程**：任意一段代码都可以通过调用Thread.currentThread()来获取这段代码的执行线程，这个线程被称为当前线程。
            - **Runnable接口**可以看作是对任务进行的抽象，任务的处理逻辑就体现在run方法中。
                - Thread类所实现的途径处理逻辑是要么什么也不做，要么直接执行target所引用的Runnable实例所实现的任务处理逻辑。
                    ```
                        public void run(){
                            if(target != null){
                                target.run();
                            }
                        }
                    ```
            - **线程两种创建方式的区别**
                1. 从面向对象编程的角度来看：第1种创建方式是一种基于继承的技术，第2种创建方式是一种基于组合的技术。
                 由于组合相对继承来说，其类和类之间的耦合性更低，因此它也更加灵活。一般认为组合是优先选用的技术。
                2. 从对象共享的角度来看：第2种方式意味着多个线程实例可以共享一个Runnable实例。在某些情况下可能导致
                 程序的运行结果出乎我们的意料。
                3. 从对象创建成本的角度来看：Java中的线程实例是一个特殊的Runnable实例，因为在创建它的时候Java虚拟机
                 会为其分配调用栈空间、内核线程等资源。创建成本相对高一些。
            - **线程属性**
                1. 编号：类型：long。用于标识不同的线程。这种编号的唯一性只在Java虚拟机的一次运行有效。重启一个Java虚拟机后编号可能重用。
                2. 名称：类型：String。面向人用于区分不同线程。
                3. 线程类型：类型：boolean。值为true表示相应线程为守护线程，否则表示为用户线程。
                    - 该属性的默认值与相应线程的父线程的该属性相同。
                    - 该属性必须在相应线程启动之前设置，即setDaemon方法的调用必须在start方法调用之前，否则setDaemon方法会抛出IllegalThreadStateException异常。
                    - **Java线程分类**：按照线程是否会阻止Java虚拟机正常停止，我们将Java中的线程分为守护线程和用户线程。用户线程会阻止Java虚拟机的正常停止。
                4. 优先级：类型int。该属性本质上是给线程调度器的提示，用于表示应用程序希望哪个线程能够优先得以运行。
                    - Java定义了1~10的10个优先级。默认值一般为5。对于一个线程而言其优先级默认与其父线程的优先级值相等。
                    - 不恰当地设置该属性可能导致严重问题（线程饥饿）。
            - Thread类的常用方法
                1. static Thread currentThread()：返回当前线程，即当前代码的执行线程。
                2. void run()：用于实现线程的任务处理逻辑。由Java虚拟机直接调用的
                3. void start()：启动相应线程。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常的抛出。
                4. void join()：等待相应线程运行结束。
                5. static void yield()：使当前线程主动放弃其对处理器的占用，可能导致当前线程被暂停。
                    - 该方法调用时当前线程可能仍然继续运动（视系统当前的运行状况而定）
                6. static void sleep(long millis)：使当前线程休眠指定的时间。
        - 1.4 无处不在的线程 
            - Java平台本身就是一个多线程的平台。
            - Java虚拟机启动的时候会创建一个main线程，该线程负责执行Java程序的入中方法(main)。
            - 垃圾回收线程对Java程序中不再使用的内存空间进行回收。
            - Java虚拟机创建专门的线程负责JIT编译器动态地将Java字节码编译为Java虚拟机宿主机处理器可直接执行的机器码。
        - 1.5 线程的层次关系
            - 子线程与父线程：假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的子线程，相应的线程A就被称为线程B的父线程。
            线程间的这种父子关系就被称为线程的层次关系。
            - 父线程与子线程之间的生命周期没有必然的联系。
            - 工作者线程：习惯上，我们也称某些子线程为工作者线程或后台线程。通常是其父线程创建来用于专门负责某项特定任务的执行的。
        - 1.6 线程的生命周期
            