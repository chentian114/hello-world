### 主题：多线程基础

### 简介
   + 学习黄文海-《Java多线程编程实战指南-核心篇》，多线程技术要点知识整理总结及体会

### 章节简介
   1. 走近Java世界中的线程
        - 简介：
        主要介绍**线程**及**多线程编程**这两个基本概念，以及**Java平台的线程API**，并通过
        一个实战案例使读者**对多线程编程有个初步和感性的认识**。
   2. 多线程编程的目标与挑战
        - 简介：
        主要介绍**多线程编程所要实现的目标**及其**面临的挑战**。明确多线程编程的目标有助
        于我们在实践中做到有的放矢，掌握多线程编程所面临的挑战使得我们在学习本书后续
        内容时能够做到有的放矢，掌握多线程编程所面临的挑战使得我们在学习本书后续内容
        时能够做到知其然而且知其所以然。
   3. Java线程同步机制
        - 简介：
        主要介绍Java平台所提供的能够用于应对多线程编程所面临的部分挑战的一些**关键字
        和标准库类(API)**，以及这些**关键字和API的性能开销、适用场景及注意事项**。
   4. 牛刀小试：玩转线程
        - 简介：
        通过实战案例介绍具体如何玩转线程以实现多线程编程的目标，并通过这些实战案例展开
        **介绍多线程编程实践中的一些实际问题及应对措施**。
   5. 线程间协作
        - 简介：
        主要介绍**线程与线程之间通过哪些常见的协作形式**来实现多线程编程的目标以及**Java所
        支持的相应标准类**。
   6. 保障线程安全的设计技术
        - 简介：
        主要从**软件设计角度**出发介绍**应对多线程编程所面临的一些挑战的常见技术**。
   7. 线程的活性故障
        - 简介
        主要介绍多线程程序可能产生的一些常见的**具有隐蔽性的故障**以及**相应的规避措施**。
   8. 线程管理
        - 简介：
        主要介绍在多线程编程中如何**更加有效和有效率地使用线程**。
   9. Java异步编程
        - 简介：
        主要从**计算模型的角度**出发介绍多线程编程中如何**利用线程来提高软件的吞吐率和响应性**。
   10. Java多线程程序的调试与测试
        - 简介：
        主要介绍Java平台中多线程程序的**调试技巧与测试手段**。
   11. 多线程编程的硬件基础与Java内存模型
        - 简介：
        主要介绍**多线程编程的硬件基础**以及Java平台为屏蔽不同硬件平台的差异而进行的抽象（**Java内存模型**）。
   12. Java多线程程序的性能调校
        - 简介：
        结合实战案例介绍与Java平台中的多线程程序紧密相关的**常用性能优化方法与技术**。
        
### 章节要点提炼
   1. 走近Java世界中的线程
        - 核心概要：1)线程和多线程编程两个概念2)Java线程API
        - 1.1 **进程、线程与任务**
        - 1.2 **多线程编程简介**
        - 1.3 **Java线程API简介**
        - 1.4 无处不在的线程
        - 1.5 线程的层次关系
        - 1.6 **线程的生命周期状态**
        - 1.7 线程的监视
        - 1.8 多线程编程简单运用案例
        - 1.9 **多线程编程的优势和风险**
        ---
        - 1.1 进程、线程与任务
            - **进程**：是程序的运行实例。运行一个Java程序的实质是启动一个Java虚拟机进程。
                - 进程是程序向操作系统申请资源（如内存空间和文件句柄）的基本单位。
                - 一个进程可以包含多个线程。
            - **线程**：是进程中可以独立执行的最小单位。
                - 同一个进程中的所有线程共享该进程中的资源。
            - **任务**：线程所要完成的计算。
                - 任务代表线程所要完成的工作。
        - 1.2 多线程编程简介
            - 多线程编程：以线程为基本抽象单位的一种编程范式。
                - 在Java平台一个线程就是一个对象。
        - 1.3 Java线程API
            - Java标准库类java.lang.Thread就是Java平台对线程的实现。
                - Thread类或其子类的一个实例就是一个线程。
            - Java平台中创建一个线程就是创建一个Thread类（或其子类）的实例。
            - 每个线程都有其要执行的任务。线程的任务逻辑在run方法中实现。
                - run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用。
            - 启动一个线程实质上是请求Java虚拟机运行相应的线程，而这个线程具体何时运行由**线程调度器**决定的。
            - 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。
            - Thread类的两个常用构造器：Thread和Thread(Runnable targe).
                - Java语言中创建线程的两种方式:1)定义Thread子类，覆盖子类的run方法，实现线程任务处理逻辑；2)创建
                一个java.lang.Runnable接口的实例，在run方法中实现任务处理逻辑，调用Thread(Runnable targe)构建器
                创建Thread类的实例。
            - 线程的run方法执行结束，相应的线程的运行也就结束了。包括正常结束及代码抛出异常而导致中止。运行结束的线程
                所占用的资源会如同其它Java对象一样被Java虚拟机垃圾回收。
            - 线程属于"一次性用品",不能通过重新调用一个已经运行结束的线程的start方法来使用重新运行。start方法只能够被
            调用一次，多次调用start方法会导致抛出IllegalThreadStateException异常。
            - 在Java平台中，一个线程就是一个对象。创建一个线程与创建其他类型的Java对象所不同的是：1)Java虚拟机会为每个
            线程分配调用栈(Call Stack)所需的内存空间。2)Java平台每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。
                - 调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码的调用。
            - **执行线程**：Java平台中的任意一段代码总是由确定的线程负责执行的。这个线程就相应地被称为这段代码的执行线程。
                - 同一段代码可以被多个线程执行。
            - **当前线程**：任意一段代码都可以通过调用Thread.currentThread()来获取这段代码的执行线程，这个线程被称为当前线程。
            - **Runnable接口**可以看作是对任务进行的抽象，任务的处理逻辑就体现在run方法中。
                - Thread类所实现的途径处理逻辑是要么什么也不做，要么直接执行target所引用的Runnable实例所实现的任务处理逻辑。
                    ```
                        public void run(){
                            if(target != null){
                                target.run();
                            }
                        }
                    ```
            - **线程两种创建方式的区别**
                1. 从面向对象编程的角度来看：第1种创建方式是一种基于继承的技术，第2种创建方式是一种基于组合的技术。
                 由于组合相对继承来说，其类和类之间的耦合性更低，因此它也更加灵活。一般认为组合是优先选用的技术。
                2. 从对象共享的角度来看：第2种方式意味着多个线程实例可以共享一个Runnable实例。在某些情况下可能导致
                 程序的运行结果出乎我们的意料。
                3. 从对象创建成本的角度来看：Java中的线程实例是一个特殊的Runnable实例，因为在创建它的时候Java虚拟机
                 会为其分配调用栈空间、内核线程等资源。创建成本相对高一些。
            - **线程属性**
                1. 编号：类型：long。用于标识不同的线程。这种编号的唯一性只在Java虚拟机的一次运行有效。重启一个Java虚拟机后编号可能重用。
                2. 名称：类型：String。面向人用于区分不同线程。
                3. 线程类型：类型：boolean。值为true表示相应线程为守护线程，否则表示为用户线程。
                    - 该属性的默认值与相应线程的父线程的该属性相同。
                    - 该属性必须在相应线程启动之前设置，即setDaemon方法的调用必须在start方法调用之前，否则setDaemon方法会抛出IllegalThreadStateException异常。
                    - **Java线程分类**：按照线程是否会阻止Java虚拟机正常停止，我们将Java中的线程分为守护线程和用户线程。用户线程会阻止Java虚拟机的正常停止。
                4. 优先级：类型int。该属性本质上是给线程调度器的提示，用于表示应用程序希望哪个线程能够优先得以运行。
                    - Java定义了1~10的10个优先级。默认值一般为5。对于一个线程而言其优先级默认与其父线程的优先级值相等。
                    - 不恰当地设置该属性可能导致严重问题（线程饥饿）。
            - Thread类的常用方法
                1. static Thread currentThread()：返回当前线程，即当前代码的执行线程。
                2. void run()：用于实现线程的任务处理逻辑。由Java虚拟机直接调用的
                3. void start()：启动相应线程。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常的抛出。
                4. void join()：等待相应线程运行结束。
                5. static void yield()：使当前线程主动放弃其对处理器的占用，可能导致当前线程被暂停。
                    - 该方法调用时当前线程可能仍然继续运动（视系统当前的运行状况而定）
                6. static void sleep(long millis)：使当前线程休眠指定的时间。
        - 1.4 无处不在的线程 
            - Java平台本身就是一个多线程的平台。
            - Java虚拟机启动的时候会创建一个main线程，该线程负责执行Java程序的入中方法(main)。
            - 垃圾回收线程对Java程序中不再使用的内存空间进行回收。
            - Java虚拟机创建专门的线程负责JIT编译器动态地将Java字节码编译为Java虚拟机宿主机处理器可直接执行的机器码。
        - 1.5 线程的层次关系
            - 子线程与父线程：假设线程A所执行的代码创建了线程B，那么，习惯上我们称线程B为线程A的子线程，相应的线程A就被称为线程B的父线程。
            线程间的这种父子关系就被称为线程的层次关系。
            - 父线程与子线程之间的生命周期没有必然的联系。
            - 工作者线程：习惯上，我们也称某些子线程为工作者线程或后台线程。通常是其父线程创建来用于专门负责某项特定任务的执行的。
        - 1.6 线程的生命周期
            [image](https://github.com/chentian114/hello-world/tree/master/thread-demo1/images/1-ThreadLifecycle.png?raw=true)
            - Thread.State定义的线程状态
                1. NEW：一个已创建而未启动的线程处理该状态。一个线程只可能有一次处理该状态。
                2. RUNNABLE：该状态是一个复合状态。它包括两个子状态：READY和RUNNING。
                    - READY：表示处于该状态的线程可以被线程调度器进行调度而使之处理RUNNING状态。
                    - RUNNING：表示处于该状态的线程正在运行。
                    - 执行Thread.yield()的线程，其状态可能会从RUNNING转换为READY。
                    - 活跃线程：处理READ状态的线程。
                3. BLOCKED：相应的线程会处于BLOCKED - 线程可以转换为RUNNABLE:
                    - 一个线程发起一个阻塞式I/O操作时 - 当阻塞式I/O操作完成后
                    - 申请一个由其它线程持有的独占资源（锁）时 - 线程获得其申请的资源
                4. WAITING：一个线程执行了某些特定方法之后就会处理这种等待其他线程执行另外一些特定操作的状态。
                    - Object.wait() - Object.notify()/notifyAll()
                    - Thread.join() - 等待的线程处理完成
                    - LockSupport.park(Object) - LockSupport.uppark(Object)
                5. TIMED_WAITING：该状态的线程并非无限制地等待其它线程执行特定操作，而是处于带有时间限制的等待状态。
                6. TERMINATED：已经执行结束的线程处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止。
                    - 一个线程在其整个生命周期中，只可能有一次处理NEW状态和TERMINATED状态。
        - 1.9 多线程编程的优势和风险
            - 多线程编程的优势
                1. 提高系统的吞吐率
                2. 提高响应性
                3. 充分利用多核处理器资源
                4. 最小化对系统资源的使用
                5. 简化程序的结构
            - 多线程编程的问题与风险
                1. 线程安全问题
                2. 线程活性问题
                3. 上下文切换
                4. 可靠性
   
            
   2. 多线程编程的目标与挑战
        - 2.1 串行、并发与并行
        - 2.2 竞态
        - 2.3 线程安全性
        - 2.4 原子性
        - 2.5 可见性
        - 2.6 有序性
        - 2.7 上下文切换
        - 2.8 线程的活性故障
        - 2.9 资源争用与调度
   
   
   3. Java线程同步机制
        - 3.1 线程同步机制简介
        - 3.2 锁概述
        - 3.3 内部锁：synchronized关键字
        - 3.4 显式锁：Lock接口
        - 3.5 锁的适用场景
        - 3.6 线程同步机制的底层助手：内存屏障
        - 3.7 锁与重排序
        - 3.8 轻量级同步机制：volatile关键字
        - 3.10 CAS与原子变量
        - 3.11 对象的发布与逸出
        
   4. 牛刀小试：玩转线程
        - 4.1 挖掘可并发点
        - 4.2 分而治之
        - 4.3 基于数据的分割实现并发化
        - 4.4 基于任务的分割实现并发化
        - 4.5 合理设置线程数
        
   5. 线程间协作
        - 5.1 等待与通知：wait/notify
        - 5.2 Java条件变量
        - 5.3 倒计时协调器：CountDownLatch
        - 5.4 栅栏(CyclicBarrier)
        - 5.5 生产者-消费者模式
        - 5.6 线程中断机制
        - 5.7 线程停止
        
   6. 保障线程安全的设计技术
        - 6.1 Java运行时存储空间
        - 6.2 无状态对象
        - 6.3 不可变对象
        - 6.4 线程特有对象
        - 6.5 装饰器模式
        - 6.6 并发集合
        
   7. 线程的活性故障
        - 7.1 死锁
        - 7.2 锁死
        - 7.3 线程饥饿
        - 7.4 活锁
        
   8. 线程管理
        - 8.1 线程组
        - 8.2 可靠性：线程的未捕获异常与监控
        - 8.3 线程工厂
        - 8.4 线程的暂挂与恢复
        - 8.5 线程的高效利用：线程池
        
   9. Java异步编程
        - 9.1 同步计算与异步计算
        - 9.2 Java Executor框架
        - 9.3 异步计算助手：FutureTask
        - 9.4 计划任务
        
   10. Java多线程程序的调试与测试
        
   11. 多线程编程的硬件基础与Java内存模型
        - 11.1 填补处理器与内存之间的鸿沟：高速缓存
        - 11.2 数据世界的交通规则：缓存一致性协议
        - 11.3 硬件缓冲区：写缓冲器与无效化队列
        - 11.4 基本内存屏障
        - 11.5 Java同步机制与内存屏障
        - 11.6 Java内存模型
        - 11.7 共享变量与性能
        
   12. Java多线程程序的性能调校
        - 12.1 Java虚拟机对内部锁的优化
        - 12.2 优化对锁的使用
        - 12.3 减少系统内耗：上下文切换
        - 12.4 多线程设计模式
        - 12.5 伪共享
   
   
   
   
   